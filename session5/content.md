# Session 5: Deploying Faust Programs

TODO: should say something about atom

## Lesson 1: Structure of the Faust Ecosystem

* Faust code -> Faust compiler -> Lower level code -> Wrapper (and its 
	hierarchy)

## Lesson 2: Faust Architectures

## Lesson 3: Plotting Signals

TODO: say something about windows

The error messages returned by the Faust compiler tell us about potential
issues in the code of a Faust program, but they don't help us debug the 
algorithm we're implementing. Indeed, a Faust program might compile without
any error but might not make any sound. 

In this short lesson, we show you how to plot the samples generated by a Faust 
program. This, combined with the ability to plot the block diagram of a Faust
code can be of great help when it comes to figure out DSP-related issues.

The Faust distribution comes with a simple architecture called `faust2plot`. So
if the Faust compiler is installed on your system, `faust2plot` should also be
available. `faust2plot` takes Faust code and turns it into a command line 
program that when executed will output a Matlab/Octave file hosting a vector or
a matrix (depending on if the signal has one or 2 channels), containing the
first N samples output by the algorithm implemented in the Faust file.

[show screen capture: code]

```
process = _~+(1);
```

Let's implement a simple counter and plot it's output in the terminal. This
code uses feedback to create a loop and add one at each sample. Let's save it
in a file, here we're calling it `cnt.dsp`, that we can then call in the 
terminal with `faust2plot`.

[show screen capture: run]

```
faust2plot cnt.dsp
```

This generates a command line program named after the Faust file and that can
be executed in the terminal.

[show screen capture: run]

```
./cnt
```

This outputs matlab (or octave) code that could be saved in a file by 
redirecting the output:

[show screen capture: run]

```
./cnt > cnt.m
``` 

You probably noticed that number of samples in `faustout` is currently limited
to 16, this can be changed using the `-n` option when calling `cnt`:

[show screen capture: run]

```
./cnt -n 50
```

Ok, now let's try a more useful example where we plot the waveform of a sine
wave using octave. 

[show screen capture: code]

```
import("stdfaust.lib");
process = os.osc(440);
```

Let's follow the same steps as previously and let's generate the octave code
from the Faust file containing the first 1000 samples:

```
./osc -n 1000 > osc.m
```

Octave is a free opensource software similar to Matlab. If it is installed on 
your system, you should now just be able to plot the waveform of our Faust
program by running:

[show screen capture: run]

```
octave --persist osc.m
``` 

Note that any standard octave or matlab operations can be carried out on this
signal. For example, its spectrogram could be plotted or we could just compute
its Fast Fourier Transform.

## Lesson 4: Using the DSP Class Generated by Faust

The most basic way to use Faust is to generate C++ code with its command line
compiler. In this lesson, we briefly describe the structure of the DSP class
generated by Faust and how it can be used in broader projects. 

Let say we want to add a reverb to an audio callback, we could write a simple
Faust program calling `dm.zita_light()` that implements a nice feedback delay
network reverb. Remember that we already used this circuit in session 1 and
that it hosts its own user interface.

[show screen capture: code]

```
import("stdfaust.lib");
process = dm.zita_light;
```

If we save this code in a file, say `reverb.dsp`, and then give it to the Faust
compiler without specifying any other option, it will return the corresponding 
C++ code directly in the terminal:

[show screen capture: run]

```
faust reverb.dsp
```

To save in a C++ file, we can just add the `-o` option followed by the name of
the file:

[show screen capture: run]

```
faust reverb.dsp -o reverb.h
```

Note that the same result can be obtained using the online editor by choosing
`source/c++` from the export menu.

Let's open `reverb.h` in a text editor (atom for example) and see what's in
there. 

[show screen capture: open reverb.h]

The `mydsp` class host a series of methods to get information about the DSP
object, to initialize it, or to run it. If we scroll down to the `public`
section of `mydsp`, the first method you'll find there is `metadata`. It allows
for the retrieval of the Faust metadata associated with the different files
imported or declared in the Faust code such as library names, licensing terms
and more.

You can retrieve the number of inputs and outputs of the object, here we have
a stereo input and a stereo output.

`init` should always be called after the `mydsp` class is instantiated and 
allows for the sampling rate to be set.

`buildUserInterface` takes a `UI` object as its main argument and passes it
the information about the various elements in the interface such as their names,
their associated metadata, their minimum and maximum values, and most 
importantly, the address of the pointer of the variable they're controlling. 
For example, `&fVslider1` points to the variable hosting the value of the
Dry/Wet parameter of the reverb.
 
Finally, the `compute` method is where all the magics happen. It basically 
implements our audio callback, therefore it should be called at each frame
period to process one complete buffer. It has 3 arguments: the size of the 
buffer to be processed, the input buffer as a double array, and the output
buffer as a double array. Note that the first dimension of these arrays
contains the various potential channels, and the second dimension the buffer
itself and its samples. 

If you look at the code in `compute`, you'll see that a for loop parses through
the samples of the buffers and computes the result.

Note that various options can be used to customize the code generated by the
Faust compiler. For example, `-cn` allows you to change the name of the 
`mydsp` class, `-vec` will produce vectorized C++ code. To get an exhaustive
list of these options, you can run `faust -h`.    

## Lesson 5: `faust2api`

TODO: explain that we assume that people have some background in Android dev.
That's just an example: should work in many other cases.

Let's create a new app project in Android studio with application name 
`FaustAudio`, company domain: whatever you want, and include C++ support.

In the following step, we can keep the default settings to target Phone and
Tablet running at least on API 17.

Let's then create an empty activity using the default settings. Finally, we 
choose the default configuration for C++ support.

At this point, we should be able to run the app in the emulator or on a real 
phone. Not much will happen since this project is empty. 

Let's now write a simple Faust synthesizer program using subtractive synthesis
quite similar to the one implemented in session 3.

[show screen capture: code]

```
import("stdfaust.lib");
freq = nentry("freq",200,40,2000,0.01);
gain = nentry("gain",1,0,1,0.01) : si.smoo;
gate = button("gate") : si.smoo; 
cutoff = nentry("cutoff",5000,40,8000,0.01) : si.smoo;
q = nentry("q",5,1,50,0.01) : si.smoo;
process = vgroup("synth",os.sawtooth(freq)*gain*gate : fi.resonlp(cutoff,q,1) <: _,_);
```

It is just made out of a sawtooth oscillator connected to a resonant lowpass 
filter. Note that we smooth the gate button in order tom implement a simple
envelope and that we split the output of the filter into 2 signals. Indeed,
the signals at the end of the `process` line will directly connect to the
physical output of the device so if the Android phone we're using has 2
speakers, we need the Faust program to output 2 signals.

TODO: auto doc for faust2api not working

## Lesson 6: JUCE

## Lesson 7: faust2smartkeyb

